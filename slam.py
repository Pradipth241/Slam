# -*- coding: utf-8 -*-
"""Slam.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1G6nFaCqFif_vrUeOYkO0kseUcCVhSwS1
"""

# Commented out IPython magic to ensure Python compatibility.
!git clone --quiet https://github.com/facebookresearch/OrienterNet
# %cd /content/OrienterNet
!python -m pip install --progress-bar off --quiet -r requirements/demo.txt
!python -m pip install --quiet -e .
!pip install --upgrade --progress-bar off --quiet plotly

pip install jupyter-server==1.16.0

pip install --upgrade google-colab

import matplotlib.pyplot as plt
from google.colab import files
def upload_file():
  uploaded = files.upload()
  (path, bin), *_ = uploaded.items()
  with open(path, 'wb') as fid:
    fid.write(bin)
  return path

from maploc.demo import Demo
from maploc.osm.viz import GeoPlotter
from maploc.osm.tiling import TileManager
from maploc.osm.viz import Colormap, plot_nodes
from maploc.utils.viz_2d import plot_images

import torch
import omegaconf
import collections
import typing

torch.serialization.add_safe_globals([
    omegaconf.base.ContainerMetadata,
    omegaconf.dictconfig.DictConfig,
    omegaconf.nodes.AnyNode,
    omegaconf.base.Metadata,
    omegaconf.listconfig.ListConfig,
    dict,
    list,
    int,
    typing.Any,
    collections.defaultdict,
])

# Now load safely
demo = Demo(num_rotations=128, device="cpu")

#@markdown Select one of the 4 example images or upload your own
image_name = 'upload!' #@param ["zurich_1", "vancouver_1", "vancouver_2", "vancouver_3", "upload!"]

#@markdown OrienterNet needs a coarse location (within ~100-200 meters) to query OpenStreetMap for the right area.
address = "mother dairy circle, Yelahanka New Town, Bengaluru, Karnataka, India" #@param {type:"string"}

#@markdown The search radius around the location prior.
tile_size_meters = "128" #@param [64, 128, 256, 512]

from google.colab import files

if not address:
  address = None

if image_name == "upload!":
  uploaded = files.upload()
  for fn in uploaded.keys():
      image_path = fn
  if not address:
      address = "India Gate, New Delhi, India"
else:
  image_path = f"assets/query_{image_name}.JPG"
  if image_name == "zurich_1":
    address = "ETH CAB Zurich"
  elif image_name == "vancouver_1":
    address = "Vancouver Waterfront Station"
  else:
    address = None

print(f"Using image {image_path} with location prior '{address}'")

# Read input image
image, camera, gravity, proj, bbox = demo.read_input_image(
    image_path,
    prior_address=address,
)

bbox = bbox + 10

# Query map tiles
from maploc.osm.tiling import TileManager
tiler = TileManager.from_bbox(proj, bbox, demo.config.data.pixel_per_meter)
canvas = tiler.query(bbox)

# Visualize only once
from maploc.osm.viz import GeoPlotter
plot = GeoPlotter(zoom=16)
plot.points(proj.latlonalt[:2], "red", name="location prior", size=10)
plot.bbox(proj.unproject(bbox), "blue", name="map tile")
plot.fig.show()

# Query OpenStreetMap for this area
from maploc.osm.tiling import TileManager
tiler = TileManager.from_bbox(proj, bbox + 10, demo.config.data.pixel_per_meter)
canvas = tiler.query(bbox)

# Show the inputs to the model: image and raster map
from maploc.osm.viz import Colormap, plot_nodes
from maploc.utils.viz_2d import plot_images
map_viz = Colormap.apply(canvas.raster)
plot_images([image, map_viz], titles=["input image", "OpenStreetMap raster"])
plot_nodes(1, canvas.raster[2], fontsize=6, size=10)

from maploc.utils.viz_localization import (
    likelihood_overlay,
    plot_dense_rotations,
    add_circle_inset,
)
from maploc.utils.viz_2d import features_to_RGB

uv, yaw, prob, neural_map, image_rectified = demo.localize(
    image, camera, canvas, gravity=gravity
)

# Visualize the predictions
overlay = likelihood_overlay(prob.numpy().max(-1), map_viz.mean(-1, keepdims=True))
(neural_map_rgb,) = features_to_RGB(neural_map.numpy())
plot_images([overlay, neural_map_rgb], titles=["prediction", "neural map"])
ax = plt.gcf().axes[0]
ax.scatter(*canvas.to_uv(bbox.center), s=5, c="red")
plot_dense_rotations(ax, prob, w=0.005, s=1/25)
add_circle_inset(ax, uv)
plt.show("notebook")

# Plot as interactive figure
bbox_ll = proj.unproject(canvas.bbox)
plot = GeoPlotter(zoom=16.5)
plot.raster(map_viz, proj.unproject(bbox), opacity=0.5)
plot.raster(likelihood_overlay(prob.numpy().max(-1)), proj.unproject(bbox))
plot.points(proj.latlonalt[:2], "red", name="location prior", size=10)
plot.points(proj.unproject(canvas.to_xy(uv)), "black", name="argmax", size=10)
plot.bbox(proj.unproject(bbox), "blue", name="map tile")
plot.fig.show()